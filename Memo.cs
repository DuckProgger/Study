#pragma warning disable 162, 219, 414, 649 // выключить некоторые предупреждения компилятора

using System;
using System.Globalization;
using System.Xml.Serialization;

class Accesses
{
    // Модификаторы доступа
    /*  
    • Члены, используемые только в классе, должны быть закрытыми.
    • Данные экземпляра, не выходящие за определенные пределы значений, должны
    быть закрытыми, а при организации доступа к ним с помощью открытых методов
    следует выполнять проверку диапазона представления чисел.
    • Если изменение члена приводит к последствиям, распространяющимся за пределы
    области действия самого члена, т.е.оказывает влияние на другие аспекты объекта,
    то этот член должен быть закрытым, а доступ к нему — контролируемым.
    • Члены, способные нанести вред объекту, если они используются неправильно,
    должны быть закрытыми.Доступ к этим членам следует организовать с помощью
    открытых методов, исключающих неправильное их использование.
    • Методы, получающие и устанавливающие значения закрытых данных, должны
    быть открытыми.
    • Переменные экземпляра допускается делать открытыми лишь в том случае,
    если нет никаких оснований для того, чтобы они были закрытыми.
    */
    public int alpha;       // Доступен всем объектам класса
    private int beta = 0;       // Доступен только внутри класса, в котором объявлен
    int gamma = 0;              // По умолчанию доступ private
    protected int teta, omron = 0;     // Доступен членам своего класса и для производных классов, но остаётся закрытым для других классов
    /*модификатор доступа protected следует применять в том случае, если требуется создать член класса, доступный для всей иерархии классов,
    но для остального кода он должен быть закрытым. А для управления доступом к значению члена класса лучше воспользоваться свойством*/

    // Конструктор базового класса
    public Accesses(int a)
    {
        alpha = a;
    }

    // Метод для записи значения в переменную с закрытым доступом
    public void SetAlpha(int а)
    {
        alpha = а;
    }

    // Метод для чтения значения переменной с закрытым доступом
    public int GetAlpha()
    {
        return alpha;
    }

    // Виртуальный метод
    public virtual void Method() // может быть переопределён в наследованном классе (не обязательно)
                                   // из переопределённого виртуального метода можно обращаться к верхнему по иерархии через ключевое слово base 
    {

    }

}

class Init
{
    public int alpha = 0;       // Доступен всем объектам класса
    private double beta = 0.0;   // Доступен только внутри класса, в котором объявлен
    public static int gamma = 0;   // Доступен всем без создания объекта класса

    // Конструктор класса при создании объекта без параметров
    public Init()
    {
        alpha = 0;
        beta = 0;
    }

    // Перегруженный конструктор класса при создании объекта с параметрами
    public Init(int i, double j)
    {
        alpha = i;
        beta = j;
    }

    // Статический конструктор
    static Init() // загружается автоматически, когда класс загружается впервые, причем до конструктора экземпляра
    {

    }

    // Перегруженный конструктор класса для демонстрации ключевого слова this
    public Init(int aplha, int beta)
    {
        this.alpha = aplha; // с помощью ключевого слова this мы ссылаемся на переменную экземпляра
        this.beta = beta;   // то есть this.alpha - это переменная, объявленная в классе, а alpha - параметр конструктора класса
    }

    // Деструктор
    ~Init()  // Вызывается при утилизации объекта (то есть при очистке памяти после уничтожения объекта, ссылающегося на этот класс)
    {

    }

    // Одномерный индексатор
    int[] a; // ссылка на базовый массив
    public int this[int index] // можно определить один из аксессоров для доступа только по чтению или только по записи
    {
        get
        {
            return a[index]; // при чтении массива а вызывается аксессор get, в котором можно определить ограничения и возвратить ошибку
        }
        set
        {
            a[index] = value; // при записи в массив а вызывается аксессор set, где так же можно установить ограничения (value - служебное слово)
        }
    }

    // Индексатор без базового массива
    public int this[short index] // можно определить один из аксессоров для доступа только по чтению или только по записи
    {
        get
        {
            return Method(index); // таким образом, когда мы создаём объект и вызываем его по идексу (ob[i]),
                                  // то вызывается аксессор get, а вместе с ним и метод, куда в качестве агрумента отправляется индекс i
        }
    // аксессор set определять не будем
    }
    int Method(int i)
    {
        return Math.Abs(i);
    }

    // Многомерные индексаторы
    int[,] b;

    public int this[int index1, int index2]
    {
        get
        {
            return b[index1, index2]; // можно так же сделать отказоустойчивый двумерный массив 
        }
    }

    // Свойства
    /* Поле зачастую создается, чтобы стать доступным для пользователей
    объекта, но при этом желательно сохранить управление над операциями,
    разрешенными для этого поля, например, ограничить диапазон значений, присваиваемых
    данному полю. Этой цели можно, конечно, добиться и с помощью закрытой
    переменной, а также методов доступа к ее значению, но свойство предоставляет более
    совершенный и рациональный путь для достижения той же самой цели.*/
    int prop; // поле, управляемое свойством Property
    public int Property
    {
        get
        {
            return prop;
        }
        set
        {
            if (value > 0) prop = value;
        }
    }

    // Автоматически реализуемые свойства
    /* Автоматически реализуемые свойства могут оказаться полезными и в тех случаях, когда с помощью
    свойств функциональные возможности программы открываются для сторонних
    пользователей, и для этой цели могут даже применяться специальные средства проектирования.*/
    public int UserCount { get; set; }
    /*в этой строке кода переменная явно не объявляется. Компилятор автоматически создает анонимное поле, в котором хранится значение.
    А в остальном автоматически реализуемое свойство UserCount подобно всем остальным свойствам.*/

    // Модификаторы доступа в аксессорах
    public int Error { get; private set; } // теперь вне класса свойство доступно только по чтению, а внутри класса по чтению/записи

    // Перечисления
    enum Enumeration : byte { first, second, third, fourth = 5, sixth} // значения нумеруются по порядку, начиная с 0, а где присвоено значение, 
                                                                // там новая точка отчёта. в итоге получилось: 0, 1, 2, 5, 6
                                                                // по умолчанию тип int 
                                                                // при вызове необходимо явно указать тип

}

class Methods
{
    public int alpha = 0;       // Доступен всем объектам класса

    // Конструктор
    public Methods (int i)
    {
        alpha = i;
    }

    // Объявление метода без возвращаемого значения и без параметров
    public void Method1()
    { return; } // прекращает выполнение метода (используется только если надо выйти из метода раньше при каком-то условии)

    // Объявление метода с возвращаемым значением типа int и двумя параметрами типа int и double
    public double Method2(int i, double j)
    {
        double result;
        return result = (double)i * j; // прекращает выполнение метода и возращает значение 
    }

    // Передача объектов методам по ссылке
    public bool Method3(Init ob)
    {
        if (ob.alpha == alpha)
            return true;
        else return false;
    }

    // Изменение аргументов, используемых для вызова метода
    public void Method4(int i)
    {
        i = 10;     // Это присваивание не окажет никакого воздействия на вызывающий аргумент, так как в метод передаётся его копия
    }
    public void Method5(Init ob)
    {
        ob.alpha = 10;     // А это присваивание изменит вызывающий объект, так как в метод передаётся его ссылка
    }

    // Модификатор ref
    public void Method6(ref int i)  // Модификатор параметра ref принудительно организует вызов по ссылке, а не по значению
    {
        i = i * i;  // В результате выполнения этой операции вызывающий аргумент изменит своё значение
    }

    // Модификатор out
    /* Модификатор параметра out подобен модификатору ref, за одним исключением:
        он служит только для передачи значения за пределы метода. Поэтому переменной,
        используемой в качестве параметра out, не нужно (да и бесполезно) присваивать
        какое-то значение. */
    public int GetParts(double n, out double frac) // параметров типа out может быть несколько
    {
        int whole;
        whole = (int)n;
        frac = n - whole; // передать дробную часть числа через параметр frac
        return whole; // возвратить целую часть числа
    }

    /* Можно провести следующую аналогию:
    параметр метода по отношению к самому методу доступен только для чтения,
    модификатор ref - доступен для записи и чтения,
    модификатор out - только для записи */

    // Использование модификаторов ref и out для ссылок на объекты
    public void Swap(ref Methods ob1, ref Methods ob2)
    {
        Methods t;
        t = ob1;
        ob1 = ob2;
        ob2 = t;
    }

    // Использование переменного числа аргументов (модификатор params)
    public int MinVal(params int[] nums) // возвращает минимальное значение из переменного набора параметров
    {
        int m;
        if (nums.Length == 0)
        {
            return 0;
        }
        m = nums[0];
        for (int i = 1; i < nums.Length; i++)
            if (nums[i] < m) m = nums[i];
        return m;
    }

    // Возврат объектов из методов
    public Methods Method7(int a)
    {
        return new Methods(alpha * a);  // создаёт новый объект с умноженным членом объекта 
    }

    // Возврат массива из метода
    public int[] FindFactors(int num, out int numfactors)
    {
        int[] facts = new int[80]; // размер массива 80 выбран произвольно
        int i, j;
        // Найти множители и поместить их в массив facts.
        for (i = 2, j = 0; i < num / 2 + 1; i++)
            if ((num % i) == 0)
            {
                facts[j] = i;
                j++;
            }
        numfactors = j; // возвращает число множителей параметра num
        return facts;  // возвращает массив, содержащий в себе все множители параметра num
    }

    // Перегрузка методов
    // В зависимости от параметров компилятор сам выберет правильную версию метода,
    // но во всех версиях метода должны отличаться операторы
    public void Overload()
    {

    }

    public void Overload(int i)
    {

    }

    public int Overload(int i, int j)
    {
        return i * j;
    }

    public double Overload(double i, double j)
    {
        return i * j;
    }

    public void Overload(ref int i)
    {

    }

    public void Overload(ref int i, out int x)
    {
        x = i + 1;
    }

    // Необязательные аргументы
    public void Method8(int a, int b = 4, int c = 8) // теперь параметры b и c являются необязательными, 
                                                     // так как если их не указать, то они инициализируются указанными значениями.
                                                     // все необязательные агрументы должны быть в правой части
    {

    }

    // Рекурсия
    public int FactR(int n)
    {
        int result;
        if (n == 1) return 1;
        result = FactR(n - 1) * n; // метод вызывает сам себя, но с декрементированным аргументом
        return result;             // в результате метод будет вызывать сам себя, пока не сработает условие if (n == 1)
                                   // и затем в строке result = FactR(n - 1) * n; будут подставляться возвращённые значения из метода, 
                                   // начиная с 1 до последнего значения (с конца обратно в начало)
    }

    // Статический метод
    public static void Method9()  // Метод, доступный без создания экземпляра класса, вызывается по имени класса
    {

    }

    // Вызов нестатического метода по ссылке на объект
    public static void Method10(Methods ob)
    {
        ob.Method1();
    }

    
}

class Overload
{
    int x, y, z;
    int[] arr;
    public int a, b;

    // Перегрузка конструкторов
    public Overload()
    {
        x = 0;
    }
    
    public Overload(int i)
    {
        x = i;
    }
    public Overload(double d)
    {
        x = (int)d;
    }
    public Overload(int i, int j)
    {

    }

    public Overload(int i, int j, int k)
    {
        x = i;
        y = j;
        z = k;
    }

    public Overload(Overload ob) // Передача класса в качестве параметра конструктора
    {
        x = ob.x;
        arr = new int[ob.x];
    }

    // Вызов конструктора с помощью ключевого слова this
    public Overload(int i, double j) : this(i, (int)j) // при аргументах i типа int и j типа double
                                                       // сначала вызывается конструктор (int i, int j), потом (int i, double j),
                                                       // так как аргумент j преобразуется в тип int
    {

    }

    // Перегрузка операторов

    // Перегрузка бинарного оператора
    public static Overload operator +(Overload ob1, Overload ob2)
    {
        Overload result = new Overload();
        result.x = ob1.x + ob2.x;       
        result.y = ob1.y + ob2.y;
        result.z = ob1.z + ob2.z;
        return result;      // таким образом можно складывать члены объектов непосредственно с помощью оператора + между экземплярами (ob1 + ob2)
                            // в противном случае пришлось бы складывать отдельно каждый член экземпляра (ob1.x + ob2.x), (ob1.y = ob2.y) и т.д.
    }

    // Перегрузка унарного оператора -
    public static Overload operator -(Overload ob)
    {
        Overload result = new Overload();
        result.x = -ob.x;
        result.y = -ob.y;
        result.z = -ob.z;
        return result;
    }

    // Перегрузка унарного оператора ++
    public static Overload operator ++(Overload op)
    {
        Overload result = new Overload();
        // Возвратить результат инкрементирования.
        result.x = op.x + 1;
        result.y = op.y + 1;
        result.z = op.z + 1;
        return result;
    }

    // Перегузка бинарного оператора для сложения объекта и числа типа int
    public static Overload operator +(Overload ob, int val) // если требуется складывать операторы, не принимая во внимание их порядок,
                                                            // то нужно ещё раз перегрузить оператор с обратным порядком аргументов
    {
        Overload result = new Overload();
        result.x = ob.x + val;
        result.y = ob.y + val;
        result.z = ob.z + val;
        return result;
    }

    // Перегрузка операторов отношения
    public static bool operator <(Overload op1, Overload op2)
    {
        if (Math.Sqrt(op1.x * op1.x + op1.y * op1.y + op1.z * op1.z) <
        Math.Sqrt(op2.x * op2.x + op2.y * op2.y + op2.z * op2.z))
            return true;
        else
            return false;
    }
    public static bool operator >(Overload op1, Overload op2)  // нужно обязательно перегрузить обратный оператор
    {
        if (Math.Sqrt(op1.x * op1.x + op1.y * op1.y + op1.z * op1.z) >
        Math.Sqrt(op2.x * op2.x + op2.y * op2.y + op2.z * op2.z))
            return true;
        else
            return false;
    }

    // Перегрузка операторов true и false
    public static bool operator true(Overload op)
    {
        if ((op.x != 0) || (op.y != 0) || (op.z != 0))
            return true; // хотя бы одна координата не равна нулю
        else
            return false;
    }
    // Перегрузить оператор false.
    public static bool operator false(Overload op)
    {
        if ((op.x == 0) && (op.y == 0) && (op.z == 0))
            return true; // все координаты равны нулю
        else
            return false;
    }

    // Перегрузка логических операторов
    public static bool operator |(Overload op1, Overload op2)
    {
        if (((op1.x != 0) || (op1.y != 0) || (op1.z != 0)) |
        ((op2.x != 0) || (op2.y != 0) || (op2.z != 0)))
            return true;
        else
            return false;
    }
    public static bool operator !(Overload op)
    {
        if ((op.x != 0) || (op.y != 0) || (op.z != 0))
            return false;
        else return true;
    }

    // Операторы преобразования
    // Неявное преобразование объекта типа Overload к типу int
    public static implicit operator int(Overload op1)
    {
        return op1.x * op1.y * op1.z;
    }

    // Явное преобразование объекта типа Overload к типу double
    public static explicit operator double(Overload op1) // нельзя одновременно указывать оператор явного и неявного преобразования одного и того же типа
    {
        return (op1.x * op1.y * op1.z);
    }

    // Перегрузка индексаторов
    public int this[int index] // можно опреедлить один из аксессоров для доступа только по чтению или только по записи
    {
        get
        {
            return arr[index]; // при чтении массива а вызывается аксессор get, в котором можно определить ограничения и возвратить ошибку
        }
        set
        {
            arr[index] = value; // при записи в массив а вызывается аксессор set, где так же можно установить ограничения
        }
    }

    public int this[double index] // теперь к массиву можно обращаться через индекс типа double
    {
        get
        {
            return arr[(int)index]; // при чтении массива а вызывается аксессор get, в котором можно определить ограничения и возвратить ошибку
        }
        set
        {
            arr[(int)index] = value; // при записи в массив а вызывается аксессор set, где так же можно установить ограничения
        }
    }


}

static class StaticClass 
{
    // В статическом классе все члены должны быть тоже статическими
    // применяется в основном, если нужно хранить связанные друг с другом статические методы (например, математические операции)
    static int Method(int i, int j)
    {
        return i * j;
    }
}

class Inheritance : Accesses, Interface // наследование всех полей, свойств и тд из базового класса Accesses, наследование интерфейса
{
    int zeta;

    // Вызов конструктора базового класса из конструктора производного класса
    public Inheritance(int arg1, int arg2) : base(arg1) // передаём значение аргумента arg1 конструктору базового класса,
                                                        // а значение arg2 конструктору производного класса
    {
        zeta = arg2;
    }

    // Сокрытие имени (оператор new)
    new int omron = 3; // имя этого члена такое же, как в базовом классе, 
                       // поэтому теперь переменная omron из класса Accesses недоступна

    // Сокрытие метода и вызов базового скрытого метода
    new public void SetAlpha(int a) // теперь при создании экземпляра класса Inheritance, будет вызываться именно этот метод
    {
        base.SetAlpha(a);           // вызвали одноимённый скрытый метод из базового класса
    }

    private void Meth()
    {
        alpha = 4;
        // beta = 0 ; доступ к полям типа private остаётся закрытым

        // Модификатор доступа protected
        teta = 0;    // а вот члены с доступом protected доступны производным классам, но не доступны другим классам
                          
        // Применение ключевого слова base для доступа к скрытому имени
        base.omron = 7;
    }

    // Переопределение виртуального метода в производном классе
    public override void Method() 
    {

    }
    /*вариант вызываемого метода при наличии нескольких методов в производных классах, определенных с помощью сокрытия имён, 
     определяется по ссылке на объект, а вариант метода при наличии нескольких виртуальных методов определяется с помощью типа объекта
    Если виртуальный метод не переопределяется, то используется его вариант из базового класса. 
    Если при наличии многоуровневой иерархии виртуальный метод не переопределяется
    в производном классе, то выполняется ближайший его вариант, обнаруживаемый вверх по иерархии */

    // Реализация методов интерфейса
    public int InterfaceMethod1()
    {
        return 5;
    }

    public void InterfaceMethod2()
    {
    }

    // Явная реализация члена интерфейса
    void Interface.InterfaceMethod3(int x) // при этом метод остаётся закрытым для объектов другого класса
    {
    }

    // Реализация интерфейсного свойства
    public int Property
    {
        get
        {
            return 5;
        }
        set
        {

        }
    }
}

abstract class absClass // абстрактный класс
{
    public abstract void Method(); // абстрактный метод (пустое тело) - в производных классах этот метод должен быть определён
                                   // с помощью модификатора override и должен содержать тело. Выбор метода при нескольких производных
                                   // классах определяется аналогично виртуальному методу

    public void Method2()          // в абстрактном классе могут содержаться обычные методы, свойства, поля и т.д.
    {

    }
    public double Edge
    { get; set; }

    public int a = 0;

    /* Выбор между интерфейсом и абстрактным классом
   Если какое-то понятие можно описать с точки зрения функционального назначения, не уточняя конкретные
   детали реализации, то следует использовать интерфейс. А если требуются некоторые
   детали реализации, то данное понятие следует представить абстрактным классом*/
}

sealed class nonInheritance // этот класс нельзя наследовать
{

}

public interface Interface // это интерфейс
{
    // В нём объявлены методы без тела, которые должны быть реализованы в классе, включившем этот интерфейс 
    int InterfaceMethod1();
    void InterfaceMethod2();
    void InterfaceMethod3(int x);

    // Интерфейсные свойства
    int Property { get; set; } // если надо предоставить доступ только по чтению или записи - убирается соответствующий аксессор

    /* Выбор между интерфейсом и абстрактным классом
    Если какое-то понятие можно описать с точки зрения функционального назначения, не уточняя конкретные
    детали реализации, то следует использовать интерфейс. А если требуются некоторые
    детали реализации, то данное понятие следует представить абстрактным классом*/

}

public interface Interface2: Interface // это интерфейс, который наследует другой интерфейс
{
    int InterfaceMethod4(); // в нём определён дополнительный метод. 
                            // Класс, наследовавший этот интерфейс должен реализовать все методы и свойства обоих интерфейсов
} // это интерфейс, наследующий другой интерфейс

struct Structure    // это структура
{ // может наследовать интерфейсы
    public int x, y;

    public Structure(int a, int b) // конструктор структуры
    {
        x = a;
        y = b;
    }

    public void Method()
    {
    }
}

class MyException
{
    static void Method()
    {
        try // внешний обработчик исключений
        {
            try // внутренний обработчик
            {
                throw new DivideByZeroException(); // ручной вызов исключения
            }
            catch (DivideByZeroException ob)          // обработка конкретного исключения во внуреннем блоке
                                                      // если надо воспользоваться объектом исключения, то присваиваем его переменной (в данном случае ob)
            {
                ob.ToString();
            }
            catch (IndexOutOfRangeException)       // обработка другого исключения во внуреннем блоке
            {
                throw;      // повторное генерирование исключения, которое обрабатывается этим catch
            }
        }
        catch (IndexOutOfRangeException) // обрабоботка конкретного исключения во внешнем блоке
        {

        }
        catch       // обработка всех остальных исключений во внешнем блоке
        {

        }
        finally // блок, который будет выполняться в любом случае после всех операторов try/catch (даже без возникновения исключительной ситуации)
        {
            
        }

        /*Наиболее часто используемые исключения, определенные в пространстве имен System:

        ArrayTypeMismatchException Тип сохраняемого значения несовместим с типом массива
        DivideByZeroException Попытка деления на нуль
        IndexOutOfRangeException Индекс оказался за границами массива
        InvalidCastException Неверно выполнено динамическое приведение типов
        OutOfMemoryException Недостаточно свободной памяти для дальнейшего выполнения
                             программы.Это исключение может быть,
                             например, сгенерировано, если для создания объекта
                             с помощью оператора new не хватает памяти
        OverflowException Произошло арифметическое переполнение
        NullReferenceException Попытка использовать пустую ссылку, т.е.ссылку, которая
                               не указывает ни на один из объектов*/


    }
}

delegate bool Delegate(int par); // это делегат. Он возвращает bool, а принимает int. Может возвращать void и не принимать параметры
                                 // объявляется вне класса

class Delegates
{

    bool Method(int x)
    {
        return true;
    }

    bool Method2(int x)
    {
        return false;
    }

    void Demo()
    {
        Delegate del = Method; // присваивание метода делегату
        del += Method2; // добавление метода в список
        del -= Method; // удаление метода из списка

        // либо можно добавлять делегаты, содержащие методы
        Delegate del2 = Method2;
        del += del2;

        int op = 0;
        bool example = del(op); // вызов делегата. будут выполняться все методы из списка с параметром op
    }

    // Анонимный метод
    Delegate del3 = delegate (int ob)
    {
        // код
        int g = ob;
        return true;
    }; // обязательно ;
 

    // Захват переменной
    static Delegate Method3()
    {
        int var = 0;
        Delegate del4 = delegate (int ob)
        {
            // код
            var++; // захваченная переменная
            return var % 2 == 0;
        };
        return del4;
    }

    void Method4()
    {
        Delegate del5 = Method3(); // теперь переменная var хоть по сути является локальной для метода Method3,
        bool b = del5(3);  // но будет существовать пока существует объект del5
    }


    // Одиночное лямбда - выражение
    Delegate del6 = x => x == 4; // тип параметра x определяется исходя из параметра делегата (int par)
                                 // после оператора => (переходит, становится) содержится выражение, результатом которого
                                 // должно быть значение такого же типа, как возвращаемое значение делегата (bool)

    // Блочное лямбда - выражение
    Delegate del7 = x =>
    {
        // код
        return true;
    };
}

namespace nEvents
{
    namespace Common
    {
        delegate void Delegate1();
        delegate int Delegate2(bool par);
        class Events
        {
            public event Delegate1 Event1; // событию присваивается делегат
            public event Delegate2 Event2; // событию присваивается делегат

            // Вызов событий
            // События можно вызывать только из класса, в котором они объявлены
            public void Call1()
            {
                Event1?.Invoke(); // вызов события, если оно не пустое
            }

            public void Call2(bool par)
            {
                Event2?.Invoke(par); // вызов события с указанным параметром, если оно не пустое
            }

        }

        class A
        {
            public void Method() { } // обработчик события
            public int Method2(bool par) // обработчик другого события
            {
                return 0;
            }

        }

        class B
        {
            public void Method() { } // обработчик события
            public int Method2(bool par) // обработчик другого события
            {
                return 0;
            }
        }

        class UseEvent
        {
            void Test1()
            {
                Events ob = new Events();
                A ob2 = new A();
                B ob3 = new B();

                ob.Event1 += ob2.Method; // добавить обработчик события (подписаться на событие)
                ob.Event1 += ob3.Method; // добавить обработчик события другого экземпляра
                ob.Call1(); // после вызова события выполнится цепочка обработчиков
            }

            void Test2()
            {
                Events ob = new Events();
                A ob2 = new A();
                B ob3 = new B();

                ob.Event2 += ob2.Method2; // добавить обработчик события (подписаться на событие)
                ob.Event2 += ob3.Method2; // добавить обработчик события другого экземпляра
                ob.Call2(true); // после вызова события выполнится цепочка обработчиков с заданным параметром
            }


        }
    }

    // использование лямбда-выражений в событиях
    namespace nLambda
    {
        delegate void Delegate1();
        delegate void Delegate2(int par);
        delegate void Delegate3(int par1, int par2);

        class Lambda
        {
            public event Delegate1 EventLambda1;
            public event Delegate2 EventLambda2;
            public event Delegate3 EventLambda3;

            public void Call1()
            {
                EventLambda1?.Invoke();
            }

            public void Call2(int par)
            {
                EventLambda2?.Invoke(par);
            }

            public void Call3(int par1, int par2)
            {
                EventLambda3?.Invoke(par1, par2);
            }
        }

        class LambdaTest
        {
            void Test1()
            {
                Lambda evt = new Lambda();
                evt.EventLambda1 += () => Console.WriteLine(); // добавление лямбда-выражения в событие без параметра
                evt.Call1(); // вызов события EventLambda1
            }

            void Test2()
            {
                Lambda evt = new Lambda();
                evt.EventLambda2 += n => Console.WriteLine(n); // добавление лямбда-выражения в событие с параметром
                evt.Call2(0); // вызов события EventLambda2
            }

            void Test3()
            {
                Lambda evt = new Lambda();
                evt.EventLambda3 += (n, m) => Console.WriteLine(n); // добавление лямбда-выражения в событие с параметром
                evt.Call3(0, 1); // вызов события EventLambda3
            }
        }


    }
}

class Examples
{
    // Метод с примерами
    static void basics()
    {
        int a = 0, b = 0, x = 0, y = 0, val = 0, absval = 0, sum = 0;
        ushort num = 8;

        // Базовые типы переменных с инициализацией соответствующими литералами
        bool bl = false;         // Логический, предоставляет два значения: “истина” или “ложь”
        byte bt = 0;            // 8-разрядный целочисленный без знака (8 бит 0 - 255)
        char ch = 'J';          // Символьный
        decimal dec = 58.7M;    // Десятичный (для финансовых расчетов - без ошибок округления) (128 бит 1Е-28 - 7,9Е+28)
        double db = 8.4D;        // С плавающей точкой двойной точности
        float f = 7.6F;         // С плавающей точкой одинарной точности
        int it = 8;              // Целочисленный (32 бита -2 147 483 648 - 2 147 483 647)
        long l = -704L;          // Длинный целочисленный (64 бита -9 223 372 036 854 775 808 - 9 223 372 036 854 775 807)
        sbyte sb = 81;          // 8-разрядный целочисленный со знаком (8 бит -128 - 127)
        short s = 5;            // Короткий целочисленный (16 бит -32 768 - 32 767)
        uint ui = 34U;           // Целочисленный без знака (32 бита 0 - 4 294 967 295)
        ulong ul = 134UL;         // Длинный целочисленный без знака (64 бита 0 - 18 446 744 073 709 551 61)
        ushort us = 43;         // Короткий целочисленный без знака (16 бит 0 - 65 535)

        // Шестнадцатеричный литерал
        uint h = 0xFFFFFFFF;

        // Неявно типизированная переменная
        var е = 2.7183F;

        // Методы вывода информации
        Console.WriteLine("{0} и {1, 5: #.##}", it, db); /* {argnum, width: fmt}
                                                        где argnum — номер выводимого аргумента, начиная с нуля; width — минимальная
                                                        ширина поля; fmt — формат.Параметры width и fmt являются необязательным */
        // или так
        Console.WriteLine(it + " и " + db);
        /*Управляющие последовательности символов
        \a Звуковой сигнал (звонок)
        \b Возврат на одну позицию
        \f Перевод страницы (переход на новую страницу)
        \n Новая строка (перевод строки)
        \r Возврат каретки
        \t Горизонтальная табуляция
        \v Вертикальная табуляция
        \0 Пустой символ
        \' Одинарная кавычка
        \" Двойная кавычка
        \\ Обратная косая черта
        */

        // Динамическая инициализация переменной
        double hypot = Math.Sqrt((a * a) + (b * b));

        // Приведение несовместимых типов
        int k = (int)hypot;

        // Операторы инкремента и декремента
        x++; // равнозначен x = x + 1
        x--; // равнозначен x = x - 1
        y = ++x; // префиксная форма - сначала инкрементирует x, потом присваивает значение y
        y = x++; // постфисная форма - сначала присваивает значение y, потом инкрементирует x

        /* Логические операторы
        & И
        | ИЛИ
        ^ Исключающее ИЛИ
        && Укороченное И
        || Укороченное ИЛИ
        ! НЕ
        */

        // Составные операторы присваивания
        x += 10; // х = х + 10;
        x -= 100; // х = х - 100;
                  // Все составные операторы: +=, -=, *=, /=, %=, &=, |=, ^=

        /* Поразрядные операторы
        Оператор Значение
        & Поразрядное И
        | Поразрядное ИЛИ
        ^ Поразрядное исключающее ИЛИ
        >> Сдвиг вправо
        << Сдвиг влево
        ~ Дополнение до 1 (унарный оператор НЕ) - инвертирует все биты
        */
        num = (ushort)(num | 1); // Применили поразрядный оператор ИЛИ, чтобы сделать число нечетным
        /* Если на число дважды применить оператор XOR, то получается исходное значение
        R1 = X ^ Y;
        R2 = R1 ^ Y; в итоге R2 = X */
        num = (ushort)~num; // Инвертировали биты переменной
        num = (ushort)(num << 2); // Сдвинули на 2 бита влево

        // Оператор ?
        absval = val < 0 ? -val : val; // получить абсолютное значение переменной val 
                                       // если val < 0, то присвоить -val, в противном случае присвоить val

        // Оператор if
        if (true)
        {

        }
        else if (true)
        {

        }
        else
        {

        }

        // Оператор switch
        switch (a)
        {
            case 1:
                a++;   // здесь можно поместить любой кодовый блок, в том числе ещё один оператор switch
                break;
            case 2:
                a++;
                break;
            case 'a': // в этом случае имеется в виду порядковый номер этого символа
                a++;
                break;
            default:    // выполняется, если ни одна из констант выбора не совпадает с заданным выражением, не является обязательной
                a--;
                break;
        }

        // Цикл for
        for (int i = 0; i < 10; i++) // переменная i существует только внутри цикла for
        {
            continue;   // следующий шаг (пропускается код после оператора continue)
        }
        for (int i = 0, j = 10; i < j; i++, j--) // Применение нескольких переменных управления циклом
        {

        }
        for (; a < 10;) // Отсутствующие части цикла for
        {
            a++;
        }
        for (; ; ) // цикл, намеренно сделанный бесконечным
        {
            break; // выход из цикла
        }
        for (a = 1; a <= 5; sum += a++) ; // Цикл без тела (в данном случае рассчитывается сумма чисел от 1 до 5)

        // Цикл while
        while (a < 20) // Условие проверяется в начале цикла
        {
            a++;
        }

        // Цикл do-while
        do
        {
            a--;
        } while (a > 0);    // Условие проверяется в конце цикла 
                            //даже если условие ложно, всё равно хотя бы раз код цикла выполнится
    }

    static void arrays()
    {
        // Одномерный массив с определённым размером
        int[] arr = new int[5];

        // Инициализация массива
        int[] arr2 = { 1, 2, 3, 4, 5 }; // компилятор автоматически распределяет память для 5 элементов

        // Другая форма инициализация массива (если новый массив присваивается уже существующей переменной ссылки на массив)
        int[] arr3;
        arr3 = new int[] { 1, 2, 3 }; // то есть можно отдельно создать переменную (ссылку на массив) 
                                      // и инициализировать её в другом месте программы

        // Двумерный массив
        int[,] arr4 = new int[3, 5]; // 3 строки и 5 столбцов
        arr4[2, 3] = 10;    // присваивание значение 3-й строке 4-му столбцу

        // Трёхмерный массив
        int[,,] arr5 = new int[2, 3, 4]; // аналогично создаётся любой многомерный массив

        // Инициализация многомерных массивов
        int[,] sqrs = {
                        { 1, 1 },
                        { 2, 4 },
                        { 3, 9 },
                        { 4, 16 },
                      };

        // Ступенчатые массивы
        int[][] jagged = new int[3][]; // 3 строки с разным количеством столбцов
        jagged[0] = new int[4];
        jagged[1] = new int[3];
        jagged[2] = new int[5];

        jagged[2][1] = 10; // присвоить значение 3-й строке 2-му столбцу

        // Массив двумерных массивов
        int[][,] jagged2 = new int[3][,];
        jagged2[0] = new int[4, 2]; // присвоить элементу ступенчатого массива ссылку на двумерный массив
        jagged2[0][1, 4] = 5;       // присвоить элементу массива с координатой (0, 1, 4) значение 5

        // Присваивание ссылок на массивы
        int[] nums1 = new int[10];
        int[] nums2 = new int[10];

        nums2 = nums1;      // теперь переменные ссылки относятся к одному и тому же объекту,
                            // а значит любые изменения nums2 изменяют nums1 и наоборот (как у экземпляров класса)

        // Применение свойства Length
        int len;

        len = arr.Length;   // переменная len равна длине массива arr (5)
        len = arr5.Length;  // переменная len равна числу элементов трёхмерного массива arr5 (2 * 3 * 4 = 24)
        // Свойство Length для ступенчатого массива
        len = jagged.Length; // возвращает количество массивов в ступенчатом массиве
        len = jagged[1].Length; // возвращает длину второго массива в ступенчатом массиве
        // Это свойство удобно использовать в цикле
        for (int i = 0; i < jagged.Length; i++)
            for (int j = 0; j < jagged[i].Length; j++)
            {
                jagged[i][j] = i * j;
            }

        // Неявно типизированный одномерный массив
        var vals = new[] { 1, 2, 3, 4, 5 };

        // Неявно типизированный двумерный массив
        var vals2 = new[,] { { 1.1, 2.2 }, { 3.3, 4.4 }, { 5.5, 6.6 } };

        // Неявно типизированный ступенчатый массив
        var jagged3 = new[]
        {
            new[] { 1, 2, 3, 4 },
            new[] { 9, 8, 7 },
            new[] { 11, 12, 13, 14, 15 }
        };

        // Цикл foreach
        foreach (int x in arr)  // в каждом шагу переменной x присваивается значение элемента массива, начиная с первого
        {                       // переменная x доступна только по чтению  
            continue;   // следующий шаг
            break;  // преждевременный выход из цикла
        }
        // аналогично работает для многомерных массивов
    }

    static void strings()
    {
        // Объявление строки
        string str = "Строка";

        // Объект типа string можно также создать из массива типа char
        char[] charray = { 't', 'е', 's', 't' };
        string strchar = new string(charray);

        // Обращение со строками
        string str1 = "Программировать в .NET лучше всего на С#.";
        string str2 = "Программировать в .NET лучше всего на С#.";
        string str3 = "Строки в C# весьма эффективны.";
        string strUp, strLow;
        int result, idx;
        // необходимо добавить пространство имён System.Globalization
        strLow = str1.ToLower(CultureInfo.CurrentCulture); /*Возвращает вариант вызывающей строки в нижнем
                                                            регистре.Способ преобразования определяется аргументом culture*/
        strUp = str1.ToUpper(CultureInfo.CurrentCulture); /* Возвращает вариант вызывающей строки в верхнем
                                                            регистре. Способ преобразования определяется аргументом culture*/
        result = string.Compare(str3, str1, StringComparison.CurrentCulture); /* Возвращает отрицательное значение, если строка
                                                                                strA меньше строки strB; положительное значение,
                                                                                если строка strA больше строки strВ; и нуль,
                                                                                если сравниваемые строки равны. Способ сравнения
                                                                                определяется аргументом comparisonType */
        idx = str2.IndexOf("Один", StringComparison.Ordinal);  /* Осуществляет поиск в вызывающей строке первого
                                                                вхождения подстроки, определяемой аргументом
                                                                value. Возвращает индекс первого совпадения
                                                                с искомой подстрокой или -1, если она не обнаружена.
                                                                Способ поиска определяется аргументом comparisonType */
        idx = str2.LastIndexOf("Один", StringComparison.Ordinal); /* Осуществляет поиск в вызывающей строке последнего
                                                                    вхождения подстроки, определяемой аргументом
                                                                    value. Возвращает индекс последнего совпадения
                                                                    с искомой подстрокой или -1, если она не обнаружена.
                                                                    Способ поиска определяется аргументом comparisonType */
        idx = str2.LastIndexOf('д');    // то же самое для символа
        if (str1 == str2)        // сравнение строк
        {

        }

        // Массивы строк
        string[] strarr = { "Это", "очень", "простой", "тест." };
        for (int i = 0; i < str.Length; i++)
        {

        }
        strarr[3] = "до предела тест!";

        // Метод substring
        string substr = str.Substring(1, 3); // возвращает часть строки, начиная со второго элемента длиной 3 символа ("тро")

        // Применение строк в операторах switch
        string[] strs = { "один", "два", "три", "два", "один" };
        foreach (string s in strs)
        {
            switch (s)
            {
                case "один":
                    Console.Write(1);
                    break;
                case "два":
                    Console.Write(2);
                    break;
                case "три":
                    Console.Write(3);
                    break;
            }
        }
    }

    static void objects()
    {
        // Переменные ссылочного типа и присваивание
        Init ob = new Init(1, 2);
        Init ob2 = new Init();
        ob2 = ob; /* теперь переменные ob и ob2 ссылаются на один и тот же объект,
        а значит изменения одной переменной повлекут за собой изменения в другой
        тот объект, на который ссылался ob2 при создании, теперь не существует и утилизируется сборщиком мусора*/

        // Вызов метода с модификаторами ref и out
        Methods ob3 = new Methods(5);
        int a = 5;
        double n = 4.25, f;
        ob3.Method6(ref a);
        ob3.GetParts(n, out f);


        // Вызов метода с переменным числом параметров (с модификатором params)
        int min;
        int[] arr = { -46, 687, 76, -74 };
        min = ob3.MinVal(a, 4, 7, 1); // в качестве параметра используется набор переменных и литералов
        min = ob3.MinVal(arr); // // в качестве параметра используется массив

        // Именованные аргументы
        ob3.Method8(5, c: 3, b: 6); // при таком вызове именованные аргументы можно указывать не по порядку,
                                    // но все неименованные аргументы должны указываться по порядку в левой части

        // Создание экземпляра класса
        Overload obj = new Overload();
        Overload obj2 = new Overload(3); // создание экземпляра через перегруженный конструктор
        Overload obj3 = new Overload(3.5);
        Overload obj4 = new Overload(obj3); // задаём в качестве аргумента другой объект

        // Инициализатор объекта
        Overload obj5 = new Overload { a = 5, b = 7 };

        // Обращение к переменной класса типа static
        Init.gamma = 3;  //(обращение по имени класса)
                         // так как экземпляр создан в другом классе, обращаться можно только к переменным с доступом public

        // Индексаторы
        Init obj6 = new Init();
        Console.WriteLine(obj6[(short)(-5)]); // мы обратились к объекту по индексу и вызвали аксессор get для типа short

        // Применить инициализаторы объектов в свойствах.
        Init obj7 = new Init { UserCount = 50 }; // инициализируем свойство при создании объекта


        // Класс object
        /* В классе object определяются методы:
        public virtual bool Equals(object ob) Определяет, является ли вызывающий объект таким же, как и объект, доступный по ссылке ob 
        public static bool Equals(object objA, object objB) Определяет, является ли объект, доступный по ссылке objA, таким же, 
                                                            как и объект, доступный по ссылке objB
        protected Finalize() Выполняет завершающие действия перед "сборкой мусора”.
                              В C# метод Finalize() доступен посредством деструктора (~)
        public virtual int GetHashCode() Возвращает хеш-код, связанный с вызывающим объектом
        public Type GetType() Получает тип объекта во время выполнения программы
        protected object MemberwiseClone() Выполняет неполное копирование объекта, т.е. копируются
                                           только члены, но не объекты, на которые ссылаются эти члены
        public static bool ReferenceEquals(obj objA, object objB) Определяет, делаются ли ссылки objA и objB на один
                                                                  и тот же объект
        public virtual string ToString() Возвращает строку, которая описывает объект*/

        // Упаковка и распаковка
        int x = 10, y;
        object obj8;
        obj8 = x; // упаковка значения х в объект
        y = (int)obj8; // распаковка значения доступного по ссылке obj8, в переменную типа int
    }

    static void overload()
    {
        // Неявное преобразование объекта к типу int
        Overload ob = new Overload(2, 3, 4);
        int i;
        i = ob; // позволяет неявно преобразовать тип Overload в тип int, так как в классе Overload есть оператор преобразования

        // Явное преобразование объекта к типу double
        double b;
        b = (double)ob;

    }

    static void interfaces()
    {
        Inheritance ob = new Inheritance(4, 7);

        // Вызов метода, определённого в интерфейсе
        ob.InterfaceMethod1();

        // Ссылка на интерфейс
        Interface ref_ob = ob;
        ref_ob.InterfaceMethod1(); // из ссылки на интерфейс можно вызывать только методы, определённые в интерфейсе, но не в объекте

        // Вызов явно реализованного члена интерфейса
        ref_ob.InterfaceMethod3(8); // вызов через экземпляр класса (ob) недоступен, так как член интерфейса является закрытым
        
    }

    static void stuctures()
    {
        Structure st1; // без вызова конструктора
        st1.x = 5;
        st1.y = 67;
        st1.Method();
        // таким образом можно сгруппировать некоторые переменные и методы и вызывать их по имени структуры

        Structure st2 = new Structure(3, 6); // вызов конструктора

    }
}






